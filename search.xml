<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C++ 服务器编程开发]]></title>
    <url>%2F2019%2F09%2F04%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-C-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[Day 01效率开发效率：C++11 -&gt; auto、lambda、move同步、异步、多线程、多进程…运行效率 预备知识 TCP/IP （网络编程都是此种协议） TCP -&gt; 传输控制协议 IP -&gt; 网际协议 Socket C++ 指针、引用、地址、循环、函数、类… std::shared_ptr、std::thread、std::aync、decltype、std::future、right、reference 第三方库 BOOST 问题： 1234567891011121314151617181920212223242526272829303132// 反转链表#include&lt;algorithm&gt;using namespace std;struct Node&#123; int* next; int value;&#125;void pirntNodeList(Node* n)&#123; while(n) &#123; cout &lt;&lt; n-&gt;value &lt;&lt; " "; n = n-&gt;next; &#125; cout &lt;&lt; "\n";&#125;Node* reverseList(Node* node)&#123; return 0;&#125;void quizOne()&#123; Node* n = 0; for(int i = 0; i&lt;3; i++) &#123; n-&gt;next = Node(i); &#125;&#125; IP网际协议详解 IP = Internet protocol suite OSI模型（Open System Interconnection model）注意: 七个层级，过于复杂。 IP模型 数据进入协议栈的封装注意: Frame data 长度有要求，最小46字节，不足添0；最大1500个字节。 MTU（最大传输单元），当传输数据 &gt; MTU时，则在IP层需要拆分成小包。 IP特点 不可靠（unreliable） 无连接（connectionless） IP数据报格式首部字段注意:【小小】 网络数据都是按照Big Endian【大端存储】传送的；家用操作系统都是Littele Endian数据存储。思考题： 123static bool isLittleEndianSystem()&#123;&#125; TCP详解TCP如何利用IP IP的特点 TCP将应用程序的传输数据分割成合适的数据块 定时器 延迟确认 检验和CRC 流量控制 TCP首部注意: IP首部20Byte，TCP首部20Byte，如需在网络传输，还需填充6Byte。 所谓的Socket , 即ip+port ip 来自 IP首部port 来自 TCP首部 Sequence Number 用于标记定时器对那一数据包计时。 Acknowlegment Number 与延迟确认有关 -&gt; if ACK set Checksum 与 检验和 有关 Data offset – 数据长度 URG -&gt; 数据紧急标志位 ACK -&gt; 数据确认标识位 PSH -&gt; push RST -&gt; reset SYN -&gt; 建立时需要 FIN -&gt; 结束 TCP状态 TPC状态变迁 蓝线–server；棕线–client；虚线–异常 TCP的连接（三次握手） TCP连接的断开（四次握手） 1.为什么断开要四次握手？ 全双工,两边都需要确认主动断开方，会进入TIME_WAIT状态 TCP数据相互传送 交互式(小数据)与成块的数据两种 时间延迟确认 Nagle算法[小数据积攒后再发送](游戏开发一般关闭这个算法) 接收窗口大小 TCP内部使用的定时器 重传定时器 坚持定时器(Persist) 保活定时器(KeepAlive)&lt;建议不开启&gt; 2MSL定时器(TIME_WAIT) 实战Wireshark使用 需安装WinCap方能使用 筛选器ip.addr==115.239.210.27 &amp;&amp; ip.port==80 Socket API (Berkeley sockets, BSD Socket)头文件 API函数 服务器和客户端的例子TCP Socket 基本流程图 Code：Server_main.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;sys/types.h&gt;#include&lt;sys/socket.h&gt;#include&lt;netinet/in.h&gt;#include&lt;arpa/inet.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;int main(int argc, char** argv)&#123; char hello[] = "hello world"; struct sockaddr_in sa; int SocketFD = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP); if(-1 == SocketFD) &#123; perror("cannot create socket"); exit(EXIT_FAILURE); &#125; memset(&amp;sa, 0, sizeof sa); sa.sin_family = AF_INET; sa.sin_port = htons(2222); sa.sin_addr.s_addr = htonl(INADDR_ANY); if(-1 == bind(SocketFD, (struct sockaddr*)&amp;sa, sizeof sa)) &#123; perror("bind failed"); close(SocketFD); exit(EXIT_FAILURE); &#125; if(-1 == listen(SocketFD, 10)) &#123; perror("listen failed"); close(SocketFD); exit(EXIT_FAILURE); &#125; for(;;) &#123; int ConnectFD = accept(SocketFD, NULL, NULL); if(0 &gt; ConnectFD) &#123; perror("accept failed"); close(SocketFD); exit(EXIT_FAILURE); &#125; int writeSize = 0; size_t totalWrite = 0; while(totalWrite &lt; sizeof(hello)) &#123; writeSize = write(ConnectFD, hello + totalWrite, sizeof(hello) - totalWrite); if(-1 == writeSize) &#123; perror("write failed"); close(ConnectFD); close(SocketFD); exit(EXIT_FAILURE); &#125; totalWrite += writeSize; &#125; if(-1 == shutdown(ConnectFD, SHUT_RDWR)) &#123; perror("shutdown failed"); close(ConnectFD); close(SocketFD); exit(EXIT_FAILURE); &#125; close(ConnectFD); &#125; close(SocketFD); return EXIT_SUCCESS; &#125; Client_main.cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;sys/types.h&gt;#include&lt;sys/socket.h&gt;#include&lt;netinet/in.h&gt;#include&lt;arpa/inet.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;int main(int argc, char** argv)&#123; struct sockaddr_in sa; int res; int SocketFD = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP); if(-1 == SocketFD) &#123; perror("cannot create socket"); exit(EXIT_FAILURE); &#125; memset(&amp;sa, 0, sizeof sa); sa.sin_family = AF_INET; sa.sin_port = htons(2222); res = inet_pton(AF_INET, "127.0.0.1", &amp;sa.sin_addr); if(-1 == connect(SocketFD, (struct sockaddr*)&amp;sa, sizeof sa)) &#123; perror("connect failed"); close(SocketFD); exit(EXIT_FAILURE); &#125; char buffer[512]; int totalRead = 0; for(;;) &#123; int readSize = 0; readSize = read(SocketFD, buffer + totalRead, sizeof(buffer)-totalRead); if(readSize == 0) &#123; break; &#125; else if(readSize == -1) &#123; perror("read failed"); close(SocketFD); exit(EXIT_FAILURE); &#125; totalRead += readSize; &#125; buffer[totalRead] = 0; printf("get from server: %s\n",buffer); (void)shutdown(SocketFD, SHUT_RDWR); close(SocketFD); return EXIT_SUCCESS;&#125;]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>网络编程</tag>
        <tag>服务器编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL常用命令汇总]]></title>
    <url>%2F2019%2F09%2F03%2FSQL%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292USE day15;-- 创建表CREATE TABLE teacher( id INT, NAME VARCHAR(20))-- 查看所有表SHOW TABLES;DESC student;DROP TABLE student;CREATE TABLE student( id INT, NAME VARCHAR(20), gender VARCHAR(2), age INT)-- ********一、增删改数据********* ----- 1.1 增加数据-- 插入所有字段。一定依次按顺序插入INSERT INTO student VALUES(1,'张三','男',20);-- 注意不能少或多字段值-- INSERT INTO student VALUES(2,'李四','女');-- 插入部分字段INSERT INTO student(id,NAME) VALUES(2,'李四');-- 1.2 修改数据-- 修改所有数据（建议少用）UPDATE student SET gender='女';-- 带条件的修改（推荐使用）UPDATE student SET gender='男' WHERE id=1; -- 修改id为1的学生，修改性别为男-- 修改多个字段,注意: SET 字段名=值,字段名=值,....UPDATE student SET gender='男',age=30 WHERE id=2;-- 1.3 删除数据-- 删除所有数据（建议少用）DELETE FROM student;-- 带条件的删除(推荐使用)DELETE FROM student WHERE id=2;-- 另一种方式-- delete from: 可以全表删除 1)可以带条件删除 2）只能删除表的数据，不能删除表的约束 3)使用delete from删除的数据可以回滚（事务）-- truncate table: 可以全表删除 1）不能带条件删除 2）即可以删除表的数据，也可以删除表的约束 3）使用truncate table删除的数据不能回滚TRUNCATE TABLE student;CREATE TABLE test( id INT PRIMARY KEY AUTO_INCREMENT, -- 自增长约束 NAME VARCHAR(20))DESC test;-- 1.DELETE FROM test;-- 2TRUNCATE TABLE test;INSERT INTO test(NAME) VALUES('张三');INSERT INTO test(NAME) VALUES('张三2');INSERT INTO test(NAME) VALUES('张三3');SELECT * FROM test;-- truncate table student where id=2; 不能带条件-- 查询数据SELECT * FROM student;-- ********二、查询数据（select）*******---- 2.1 查询所有列SELECT * FROM student;-- 2.2 查询指定列SELECT id,NAME,gender FROM student;-- 2.3 查询时指定别名（as）-- 注意： 在多表查询是经常使用表的别名SELECT id AS '编号',NAME AS '姓名' FROM student;-- 2.4 查询时添加常量列-- 需求： 在查询student表时添加一个班级列，内容为“java就业班”SELECT id,NAME,gender,age,'java就业班' AS '年级' FROM student;-- 2.5 查询时合并列-- 需求： 查询每个学生的servlet和jsp的总成绩SELECT id,NAME,(servlet+jsp) AS '总成绩' FROM student;-- 注意：合并列只能合并数值类型的字段SELECT id,(NAME+servlet) FROM student;-- 2.6 查询时去除重复记录(DISTINCT)-- 需求： 查询学生的性别 男 女SELECT DISTINCT gender FROM student;-- 另一种语法SELECT DISTINCT(gender) FROM student;-- 需求: 查询学生所在的地区SELECT DISTINCT address FROM student;-- 2.7 条件查询(where)-- 2.7.1 逻辑条件： and(与) or(或)-- 需求： 查询id为2，且姓名为李四的学生SELECT * FROM student WHERE id=2 AND NAME='李四'; -- 交集-- 需求： 查询id为2，或姓名为张三的学生SELECT * FROM student WHERE id=2 OR NAME='张三'; -- 并集-- 2.7.2 比较条件： &gt; &lt; &gt;= &lt;= = &lt;&gt;(不等于) between and (等价于&gt;= 且 &lt;=)-- 需求： 查询servlet成绩大于70分的学生SELECT * FROM student WHERE servlet&gt;70;-- 需求： 查询jsp成绩大于等于75，且小于等于90分的学生SELECT * FROM student WHERE jsp&gt;=75 AND jsp&lt;=90;-- 另一个语法SELECT * FROM student WHERE jsp BETWEEN 75 AND 90; -- (包前包后)SELECT * FROM student WHERE gender&lt;&gt;'男';-- 2.7.3 判空条件(null 空字符串)： is null / is not null / ='' / &lt;&gt;''-- 需求： 查询地址为空的学生（包括null和空字符串）-- null vs 空字符串-- null：表示没有值-- 空字符串：有值的！-- 判断nullSELECT * FROM student WHERE address IS NULL ;-- 判断空字符串SELECT * FROM student WHERE address='';SELECT * FROM student WHERE address IS NULL OR address=''; -- （包括null和空字符串）-- 需求： 查询有地址的学生(不包括null和空字符串)SELECT * FROM student WHERE address IS NOT NULL AND address&lt;&gt;'';-- 2.7.4 模糊条件： like-- 通常使用以下替换标记：-- % : 表示任意个字符-- _ : 表示一个字符-- 需求： 查询姓‘张’的学生SELECT * FROM student WHERE NAME LIKE '李%';-- 需求： 查询姓‘李’，且姓名只有两个字的学生SELECT * FROM student WHERE NAME LIKE '李_';--- 练习 --CREATE TABLE student2( id INT, NAME VARCHAR(20), chinese FLOAT, english FLOAT, math FLOAT);INSERT INTO student2(id,NAME,chinese,english,math) VALUES(1,'张小明',89,78,90);INSERT INTO student2(id,NAME,chinese,english,math) VALUES(2,'李进',67,53,95);INSERT INTO student2(id,NAME,chinese,english,math) VALUES(3,'王五',87,78,77);INSERT INTO student2(id,NAME,chinese,english,math) VALUES(4,'李一',88,98,92);INSERT INTO student2(id,NAME,chinese,english,math) VALUES(5,'李来财',82,84,67);INSERT INTO student2(id,NAME,chinese,english,math) VALUES(6,'张进宝',55,85,45);INSERT INTO student2(id,NAME,chinese,english,math) VALUES(7,'黄蓉',75,65,30);-- 查询表中所有学生的信息。SELECT * FROM student2;-- 查询表中所有学生的姓名和对应的英语成绩。SELECT NAME,english FROM student2;-- 过滤表中英语成绩的重复数据SELECT DISTINCT(english) FROM student2;-- 使用别名表示学生分数。SELECT NAME AS '姓名',chinese AS '语文',english AS '英语',math AS '数学' FROM student2; -- 查询姓名为李一的学生成绩SELECT * FROM student2 WHERE NAME='李一';-- 查询英语成绩大于等于90分的同学SELECT * FROM student2 WHERE english&gt;=90;-- 查询总分大于200分的所有同学SELECT * FROM student2 WHERE (chinese+english+math)&gt;200; -- 查询所有姓李的学生英语成绩。SELECT NAME,english FROM student2 WHERE NAME LIKE '李%';-- 查询英语&gt;80或者总分&gt;200的同学SELECT * FROM student2 WHERE english&gt;80 OR (chinese+english+math)&gt;200-- 统计每个学生的总分。SELECT id,NAME,(chinese+english+math) AS '总成绩' FROM student2;-- 在所有学生总分数上加10分特长分。SELECT id,NAME,(chinese+english+math+10) AS '总成绩' FROM student2;SELECT * FROM student;-- 2.8 聚合查询（使用聚合函数的查询） -- 常用的聚合函数： sum() avg() max() min() count()-- 需求：查询学生的servlet的总成绩 (sum() :求和函数)SELECT SUM(servlet) AS 'servlet的总成绩' FROM student;-- 需求： 查询学生的servlet的平均分SELECT AVG(servlet) AS 'servlet的平均分' FROM student;-- 需求: 查询当前servlet最高分SELECT MAX(servlet) AS '最高分' FROM student;-- 需求： 查询最低分SELECT MIN(servlet) AS '最低分' FROM student;-- 需求： 统计当前有多少学生(count(字段))SELECT COUNT(*) FROM student;SELECT COUNT(id) FROM student;-- 注意：count（）函数统计的数量不包含null的数据-- 使用count统计表的记录数，要使用不包含null值的字段SELECT COUNT(age) FROM student;SELECT * FROM student;-- 2.9 分页查询（limit 起始行,查询几行）-- 起始行从0开始-- 分页：当前页 每页显示多少条-- 分页查询当前页的数据的sql: SELECT * FROM student LIMIT (当前页-1)*每页显示多少条,每页显示多少条;-- 需求： 查询第1,2条记录（第1页的数据）SELECT * FROM student LIMIT 0,2;-- 查询第3,4条记录（第2页的数据）SELECT * FROM student LIMIT 2,2;-- 查询第5,6条记录（第3页的数据）SELECT * FROM student LIMIT 4,2;-- 查询第7,8条记录 (没有记录不显示)SELECT * FROM student LIMIT 6,2;-- 2.10 查询排序（order by ）-- 语法 ：order by 字段 asc/desc-- asc: 顺序，正序。数值：递增，字母：自然顺序（a-z）-- desc: 倒序，反序。数值：递减，字母：自然反序(z-a)-- 默认情况下，按照插入记录顺序排序SELECT * FROM student;-- 需求： 按照id顺序排序SELECT * FROM student ORDER BY id ASC;SELECT * FROM student ORDER BY id; -- 默认正序SELECT * FROM student ORDER BY id DESC;-- 反序-- 注意：多个排序条件-- 需求： 按照servlet正序，按照jsp的倒序SELECT * FROM student ORDER BY servlet ASC,jsp DESC;-- 2.11 分组查询(group by)-- 需求： 查询男女的人数-- 预期结果： -- 男 3 --- 女 2 -- 1) 把学生按照性别分组(GROUP BY gender) -- 2) 统计每组的人数(COUNT(*))SELECT gender,COUNT(*) FROM student GROUP BY gender;-- 2.12 分组查询后筛选-- 需求： 查询总人数大于2的性别-- 1) 查询男女的人数-- 2）筛选出人数大于2的记录(having)--- 注意： 分组之前条件使用where关键字，分组之前条件使用having关键字SELECT gender,COUNT(*) FROM student WHERE GROUP BY gender HAVING COUNT(*)&gt;2;-- 给student表添加servlet和jsp成绩列ALTER TABLE student ADD servlet INT,ADD jsp INT;ALTER TABLE student ADD servlet INT;ALTER TABLE student ADD address VARCHAR(10);DESC student;UPDATE student SET servlet=70,jsp=85 WHERE id=1;UPDATE student SET servlet=65,jsp=90 WHERE id=2;UPDATE student SET gender='女' WHERE id=2;UPDATE student SET address='广州天河' WHERE id=1;UPDATE student SET address='广州天河' WHERE id=2;UPDATE student SET address='广州番禺' WHERE id=3;INSERT INTO student VALUES(4,'陈六','男',28,75,80,'');INSERT INTO student VALUES(5,'李七','男',30,64,83,NULL);INSERT INTO student VALUES(6,'李八八','男',35,67,82,'广州天河');]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用hexo+github搭建博客 笔记]]></title>
    <url>%2F2019%2F09%2F01%2F%E4%BD%BF%E7%94%A8hexo%2Bgithub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[常用命令汇总 命令 简写 作用 hexo deploy hexo d 部署到github等 hexo server hexo s 开启服务器, –debug 开启调试模式 hexo clean 清楚缓存文件及静态文件 hexo generate hexo g 生成静态网页,-f 等同于hexo clean &amp;&amp; hexo g; -d 等同于hexo g &amp;&amp; hexo d hexo new “new file title” 创建新文章，若题目中无空格，可省去双引号 hexo new page tags 在source创建tags文件夹，且生成index.md的文章 注意：可以做个命令统计脚本，根据使用频次排序上述命令。 本地资料备份已在github添加hexo分支，本地资料push到hexo分支，hexo部署由hexo d自动推送到master分支。 1git push origin hexo 安装 hexo12345npm install hexo-cli -ghexo init blogcd blognpm installhexo server 更换NexT 主题12cd bloggit clone https://github.com/iissnan/hexo-theme-next themes/next 修改配置文件 打开_config.yml: 修改主题一行为： 1theme: next 写文章1hexo new [layout] &lt;title&gt; 默认layout使用 _config.yml 中的 default_layout 参数若标题中包含空格，请使用引号括起来。 1hexo new page --path about/me "About me" # 自定义新文章路径 举例 1hexo new first.md 编辑first.md文件即可 本地启动服务器123hexo server# 可简写为hexo s 默认网址：![http://localhost:4000/]-p 重设端口号-s 只使用静态文件 部署到github 安装 github部署工具 1npm install hexo-deployer-git --save 修改_config.yml 123deploy: type: git repo: https://github.com/Narglc/Narglc.github.io 部署到github 123hexo deploy# 可简写为：hexo d generate vs deploy1234hexo generate # 生成静态文件 -d,--deploy # 文件生成后立即部署网站# 可简写为：hexo g hexo g 仅仅生成静态文件，用于本地部署；hexo d 可推送到github部署 clean1hexo clean #清除缓存文件 (db.json) 和已生成的静态文件 (public)。 代码高亮样式12# normal | night | night eighties | night blue | night bright # 5种可用highlight_theme: night 添加阅读全文按钮 [暂未开启]只显示文章一部分，多余的需要点击阅读全文来查看，需要在文章中添加 1&lt;!--more--&gt; 设置网站缩略图标修改站点配置文件_config.yml中small、medium、apple_touch_icon对应图片地址： 12345favicon: small: /images/favicon-16x16-next.png medium: /images/favicon-32x32-next.png apple_touch_icon: /images/apple-touch-icon-next.png safari_pinned_tab: /images/logo.svg 本地搜索功能安装 hexo-generator-searchdb 插件1npm install hexo-generator-searchdb --save 修改next主题配置文件_config.yml:12local_search: enable: true 站点配置文件_config.yml的Extensions后添加：12345search: path: search.xml field: post format: html limit: 10000 侧边栏社交链接修改next主题配置文件_config.yml: 123456789social: E-Mail: mailto:qingcheliuzhi@qq.com || envelope GitHub: https://github.com/Narglc || github 豆瓣: https://www.douban.com/people/Narglc/ || doubansocial_icons: enable: true icons_only: false transition: false 微博: weibo # 可设置上述对应的图标 注意： || 前面是链接地址，后面是FontAwsone字符库的图标名 打赏修改站点配置文件_config.yml: 1234# Rewardreward_comment: Donate comment herewechatpay: /images/wechatpay.jpgalipay: /images/alipay.jpg 文章末尾添加版权信息实现手动修改主题目录下的 layout/_macro/post.swig 文件，找到 post-footer 标签，添加以下内容div内代码段： 即，将div内代码段插入footer标签开始处。 123456789101112131415161718192021&lt;footer class="post-footer"&gt; &lt;div&gt; &#123;# 此处判断是否在索引列表中 #&#125; &#123;% if not is_index %&#125; &lt;ul class="post-copyright"&gt; &lt;li class="post-copyright-author"&gt; &lt;strong&gt;本文作者：&lt;/strong&gt;&#123;&#123; theme.author &#125;&#125; &lt;/li&gt; &lt;li class="post-copyright-link"&gt; &lt;strong&gt;本文链接：&lt;/strong&gt; &lt;a href="&#123;&#123; url_for(page.path) &#125;&#125;" title="&#123;&#123; page.title &#125;&#125;"&gt;&#123;&#123; page.path &#125;&#125;&lt;/a&gt; &lt;/li&gt; &lt;li class="post-copyright-license"&gt; &lt;strong&gt;版权： &lt;/strong&gt; 本站文章均采用 &lt;a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" rel="external nofollow" target="_blank"&gt;CC BY-NC-SA 3.0 CN&lt;/a&gt; 许可协议，请勿用于商业，转载注明出处！ &lt;/li&gt; &lt;/ul&gt; &#123;% endif %&#125; &lt;/div&gt;[footer 原有内容]&lt;/footer&gt; 添加显示格式修改主题目录下的 source/css/_custom/custom.styl 文件: 1234567.post-copyright &#123; margin: 1em 0 0; padding: 0.5em 1em; border-left: 3px solid #ff1700; background-color: #f9f9f9; list-style: none;&#125; 站点访问计数使用不蒜子脚本实现计数 新实现Next 主题在版本6.0以上已经内置了不蒜子访客统计的代码，修改主题配置文件_config.yml即可 123456789101112131415busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: &lt;i class="fa fa-user"&gt;&lt;/i&gt; 访问人数 site_uv_footer: 人 # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class="fa fa-eye"&gt;&lt;/i&gt; 总访问量 site_pv_footer: 次 # custom pv span for one page only page_pv: true page_pv_header: &lt;i class="fa fa-file-o"&gt;&lt;/i&gt; 阅读数 page_pv_footer:]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F08%2F30%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 文本居中的引用123456789&lt;!-- HTML方式: 直接在 Markdown 文件中编写 HTML 来调用 --&gt;&lt;!-- 其中 class="blockquote-center" 是必须的 --&gt;&lt;blockquote class="blockquote-center"&gt;blah blah blah&lt;/blockquote&gt;&lt;!-- 标签 方式，要求版本在0.4.5或以上 --&gt;&#123;% centerquote %&#125;blah blah blah&#123;% endcenterquote %&#125;&lt;!-- 标签别名 --&gt;&#123;% cq %&#125; blah blah blah &#123;% endcq %&#125; 效果如下： blah blah blah blah blah blah blah blah blah]]></content>
  </entry>
</search>
